// +build ignore

package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"strings"
)

func main() {
	var buf bytes.Buffer
	outf := func(format string, args ...interface{}) {
		fmt.Fprintf(&buf, format, args...)
	}

	outf("// Code generated by mkunmarshalyaml.go. DO NOT EDIT.")
	outf("\n\npackage openapi")
	outf("\n\nimport (")
	outf("\n\"errors\"")
	outf("\n\"strconv\"")
	outf("\n\"strings\"")
	outf("\n")
	outf("\nyaml \"github.com/goccy/go-yaml\"")
	outf("\n)")

	f, err := parser.ParseFile(token.NewFileSet(), "interfaces.go", nil, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}
	for _, decl := range f.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}
		if genDecl.Doc == nil || len(genDecl.Doc.List) == 0 || genDecl.Doc.List[0].Text != "//+object" {
			log.Printf("%v is not an openapi object. skip.", genDecl.Specs[0].(*ast.TypeSpec).Name.Name)
			continue
		}

		for _, spec := range genDecl.Specs {
			typ, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}
			st, ok := typ.Type.(*ast.StructType)
			if !ok {
				continue
			}
			outf("\n\nfunc (v *%s) UnmarshalYAML(b []byte) error {", typ.Name.Name)
			outf("\nvar proxy map[string]raw")
			outf("\nif err := yaml.Unmarshal(b, &proxy); err != nil {")
			outf("\nreturn err")
			outf("\n}")

			for _, field := range st.Fields.List {
				fn := field.Names[0].Name
				yn := yamlName(field)
				// special cases
				switch yn {
				case "-":
					continue
				case "paths":
					if typ.Name.Name == "Paths" {
						outf("\npaths := map[string]*PathItem{}")
						outf("\nfor key, val := range proxy {")
						outf("\nif strings.HasPrefix(key, \"x-\") {")
						outf("\ncontinue")
						outf("\n}")
						outf("\nvar pathItem PathItem")
						outf("\nif err := yaml.Unmarshal(val, &pathItem); err != nil {")
						outf("\nreturn err")
						outf("\n}")
						outf("\npaths[key] = &pathItem")
						outf("\n}")
						outf("\nv.paths = paths")
						continue
					}
				case "responses":
					if typ.Name.Name == "Responses" {
						outf("\nresponses := map[string]*Response{}")
						outf("\nfor key, val := range proxy {")
						outf("\nif strings.HasPrefix(key, \"x-\") {")
						outf("\ncontinue")
						outf("\n}")
						outf("\nvar response Response")
						outf("\nif err := yaml.Unmarshal(val, &response); err != nil {")
						outf("\nreturn err")
						outf("\n}")
						outf("\nresponses[key] = &response")
						outf("\n}")
						outf("\nv.responses = responses")
					}
				case "extension":
					outf("\n\nv.extension = extension(proxy)")
					continue
				}
				unmarshalField := func() {
					outf("\nif err := yaml.Unmarshal(%sBytes, &%[1]s); err != nil {", fn)
					outf("\nreturn err")
					outf("\n}")
				}

				outf("\n\n")
				required := isRequired(field)
				if required {
					outf("%sBytes, ok := proxy[\"%[1]s\"]", yn)
					outf("\nif !ok {")
					outf("\nreturn errors.New(`\"%s\" field is required`)", yn)
					outf("\n}")
				} else {
					outf("if %sBytes, ok := proxy[\"%[1]s\"]; ok {", yn)
				}

				switch t := field.Type.(type) {
				case *ast.Ident: // built-in type
					switch t.Name {
					case "string":
						outf("\nv.%s = string(%sBytes)", fn, yn)
					case "bool":
						outf("\nt, err := strconv.ParseBool(string(%sBytes))", yn)
						outf("\nif err != nil {")
						outf("\nreturn err")
						outf("\n}")
						outf("\nv.%s = t", fn)
					case "int":
						outf("\ni, err := strconv.Atoi(string(%sBytes))", yn)
						outf("\nif err != nil {")
						outf("\nreturn err")
						outf("\n}")
						outf("\nv.%s = i", fn)
					default:
						log.Fatalf("unknown type for %s: %s", fn, t.Name)
					}
				default:
					outf("\nvar %s %s", fn, strings.TrimPrefix(ast2type(t), "*"))
					unmarshalField()
					outf("\nv.%s = ", fn)
					if _, ok := t.(*ast.StarExpr); ok {
						outf("&")
					}
					outf("%s", fn)
				}
				if !required {
					outf("\n}")
				}
			}
			outf("\nreturn nil")
			outf("\n}")
		}
	}
	src, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatal(err)
	}
	if err := ioutil.WriteFile("unmarshalyaml_gen.go", src, 0644); err != nil {
		log.Fatal(err)
	}
}

func isRequired(field *ast.Field) bool {
	if field.Tag == nil {
		return false
	}
	for _, f := range strings.Fields(strings.Trim(field.Tag.Value, "`")) {
		tag := strings.Split(f, ":")
		if tag[0] == "required" && len(tag[0]) > 2 {
			return true
		}
	}
	return false
}

func yamlName(field *ast.Field) string {
	if field.Tag == nil {
		return field.Names[0].Name
	}
	for _, f := range strings.Fields(strings.Trim(field.Tag.Value, "`")) {
		tag := strings.Split(f, ":")
		if tag[0] == "yaml" {
			yn := strings.Split(strings.Trim(tag[1], `"`), ",")[0]
			if yn != "" {
				return yn
			}
		}
	}
	return field.Names[0].Name
}
