// +build ignore

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"strconv"
	"strings"
)

func main() {
	only := flag.String("only", "", "")
	flag.Parse()
	var buf bytes.Buffer
	outf := func(format string, args ...interface{}) {
		fmt.Fprintf(&buf, format, args...)
	}

	outf("// Code generated by mkunmarshalyaml.go. DO NOT EDIT.")
	outf("\n\npackage openapi")
	outf("\n\nimport (")
	outf("\n\"errors\"")
	outf("\n\"net/url\"")
	outf("\n\"regexp\"")
	outf("\n\"strings\"")
	outf("\n")
	outf("\nyaml \"github.com/goccy/go-yaml\"")
	outf("\n)")

	f, err := parser.ParseFile(token.NewFileSet(), "interfaces.go", nil, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}
	for _, decl := range f.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}
		if genDecl.Doc == nil || len(genDecl.Doc.List) == 0 || genDecl.Doc.List[0].Text != "//+object" {
			log.Printf("%v is not an openapi object. skip.", genDecl.Specs[0].(*ast.TypeSpec).Name.Name)
			continue
		}

		for _, spec := range genDecl.Specs {
			typ, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			st, ok := typ.Type.(*ast.StructType)
			if !ok {
				continue
			}

			if *only != "" && typ.Name.Name != *only {
				continue
			}

			log.Printf("generate %s.Unmarshal()", typ.Name.Name)
			outf("\n\nfunc (v *%s) UnmarshalYAML(b []byte) error {", typ.Name.Name)
			outf("\nvar proxy map[string]raw")
			outf("\nif err := yaml.Unmarshal(b, &proxy); err != nil {")
			outf("\nreturn err")
			outf("\n}")

			var noUnknown bool

			for _, field := range st.Fields.List {
				if yamlName(field, parseTags(field)) == "$ref" {
					outf("\nif referenceBytes, ok := proxy[\"$ref\"]; ok {")
					outf("\nvar referenceVal string")
					outf("\nif err := yaml.Unmarshal(referenceBytes, &referenceVal); err != nil {")
					outf("\nreturn err")
					outf("\n}")
					outf("\nv.reference = referenceVal")
					outf("\ndelete(proxy, \"$ref\")")
					outf("\nreturn nil")
					outf("\n}")
					continue
				}
			}

			for _, field := range st.Fields.List {
				fn := field.Names[0].Name
				tag := parseTags(field)
				yn := yamlName(field, tag)
				required := isRequired(tag)

				if yn == "-" || yn == "$ref" {
					continue
				}

				if isInline(tag) {
					ft, ok := field.Type.(*ast.MapType)
					if !ok {
						log.Fatalf("exected map for inline %s but %s", yn, field.Type)
					}
					formatTag := tag["format"]
					outf("\n%s := map[string]%s{}", fn, ast2type(ft.Value))
					outf("\nfor key, val := range proxy {")
					if len(formatTag) > 0 {
						switch formatTag[0] {
						case "prefix":
							outf("\nif !strings.HasPrefix(key, \"%s\") {", formatTag[1])
							outf("\ncontinue")
							outf("\n}")
						case "regexp":
							outf("\n%sRegexp := regexp.MustCompile(`%s`)", fn, formatTag[1])
							outf("\nif !%sRegexp.MatchString(key) {", fn)
							outf("\ncontinue")
							outf("\n}")
						case "runtime":
							outf("\nif !IsRuntimeExpr(key) {")
							outf("\ncontinue")
							outf("\n}")
						}
					} else {
						noUnknown = true
					}
					outf("\nvar %sv %s", fn, strings.TrimPrefix(ast2type(ft.Value), "*"))
					outf("\nif err := yaml.Unmarshal(val, &%sv); err != nil {", fn)
					outf("\nreturn err")
					outf("\n}")
					outf("\n%s[key] = ", fn)
					if _, ok := ft.Value.(*ast.StarExpr); ok {
						outf("&")
					}
					outf("%sv", fn)
					outf("\ndelete(proxy, key)")
					outf("\n}")
					outf("\nif len(%s) != 0 {", fn)
					outf("\nv.%s = %s", fn, fn)
					outf("\n}")
					continue
				}

				outf("\n\n")
				if required {
					outf("%sBytes, ok := proxy[\"%s\"]", fn, yn)
					outf("\nif !ok {")
					outf("\nreturn ErrRequired(%s)", strconv.Quote(yn))
					outf("\n}")
				} else {
					outf("if %sBytes, ok := proxy[\"%s\"]; ok {", fn, yn)
				}

				typName := strings.TrimPrefix(ast2type(field.Type), "*")
				outf("\nvar %sVal %s", fn, typName)
				outf("\nif err := yaml.Unmarshal(%sBytes, &%[1]sVal); err != nil {", fn)
				outf("\nreturn err")
				outf("\n}")
				outf("\nv.%s = ", fn)
				if _, ok := field.Type.(*ast.StarExpr); ok {
					outf("&")
				}
				outf("%sVal", fn)
				outf("\ndelete(proxy, `%s`)", yn)
				if !required {
					outf("\n}")
				}
				switch tag.get("format") {
				case "semver":
					outf("\n\nif !isValidSemVer(v.%s) {", fn)
					outf("\nreturn errors.New(`\"%s\" field must be a valid semantic version but not`)", yn)
					outf("\n}")
				case "url":
					outf("\n")
					if !required {
						outf("\nif v.%s != \"\" {", fn)
					}

					if len(tag["format"]) > 1 && tag["format"][1] == "template" {
						outf("\nif err := validateURLTemplate(v.%s)", fn)
					} else {
						outf("\nif _, err := url.ParseRequestURI(v.%s)", fn)
					}
					outf("; err != nil {")
					outf("\nreturn err")
					outf("\n}")
					if !required {
						outf("\n}")
					}
				case "email":
					outf("\n")
					if !required {
						outf("\nif v.%s != \"\" {", fn)
					}
					outf("\n\nif v.%s != \"\" && !emailRegexp.MatchString(v.%[1]s) {", fn)
					outf("\nreturn errors.New(`\"%s\" field must be an email address`)", yn)
					outf("\n}")
					if !required {
						outf("\n}")
					}
				case "runtime":
					if _, ok := field.Type.(*ast.MapType); ok {
						outf("\n\nfor key := range v.%s {", fn)
						outf("\nif !matchRuntimeExpr(key) {")
						outf("\nreturn errors.New(`the keys of \"%s\" must be a runtime expression`)", yn)
						outf("\n}")
						outf("\n}")
					}
				case "regexp":
					if _, ok := field.Type.(*ast.MapType); ok {
						outf("\n\n%sRegexp := regexp.MustCompile(`%s`)", fn, tag["format"][1])
						outf("\nfor key := range v.%s {", fn)
						outf("\nif !%sRegexp.MatchString(v.%s) {", fn, fn)
						outf("\nreturn errors.New(`the keys of \"%s\" must be match \"%s\"`)", yn, tag["format"][1])
						outf("\n}")
					}
				}
				if list, ok := tag["oneof"]; ok {
					outf("\n")
					if !required {
						outf("\nif v.%s != \"\" {", fn)
					}
					outf("\nif !isOneOf(v.%s, %#v) {", fn, list)
					outf("\nreturn errors.New(`\"%s\" field must be one of [%s]`)", yn, strings.Join(quoteEachString(list), ", "))
					outf("\n}")
					if !required {
						outf("\n}")
					}
				}
			}
			if !noUnknown {
				outf("\nif len(proxy) != 0 {")
				outf("\nfor k := range proxy {")
				outf("\nreturn ErrUnknownKey(k)")
				outf("\n}")
				outf("\n}")
			}

			outf("\nreturn nil")
			outf("\n}")
		}
	}
	src, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Printf("%s\n", buf.Bytes())

		log.Fatalf("error on formatting: %+v", err)
	}
	if err := ioutil.WriteFile("unmarshalyaml_gen.go", src, 0644); err != nil {
		log.Fatal(err)
	}
}

func formatValidation(outf func(string, ...interface{}), fieldname, yamlname string, field *ast.Field, tag tags, required bool) {

}

func isInline(t tags) bool {
	vs := t["yaml"]
	if len(vs) < 2 {
		return false
	}
	for _, v := range vs[1:] {
		if v == "inline" {
			return true
		}
	}
	return false
}

func isRequired(t tags) bool {
	return t.get("required") != ""
}

func yamlName(field *ast.Field, t tags) string {
	yn := t.get("yaml")
	if yn != "" {
		return yn
	}
	return field.Names[0].Name
}

func quoteEachString(list []string) []string {
	ret := make([]string, len(list))
	for i := range list {
		ret[i] = strconv.Quote(list[i])
	}
	return ret
}
