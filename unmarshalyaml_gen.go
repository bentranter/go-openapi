// Code generated by mkunmarshalyaml.go. DO NOT EDIT.

package openapi

import (
	"errors"
	"net/url"
	"regexp"
	"strings"

	yaml "github.com/goccy/go-yaml"
)

func (v *OpenAPI) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	openapiBytes, ok := proxy["openapi"]
	if !ok {
		return errors.New(`"openapi" field is required`)
	}
	var openapiVal string
	if err := yaml.Unmarshal(openapiBytes, &openapiVal); err != nil {
		return err
	}
	v.openapi = openapiVal

	if !isValidSemVer(v.openapi) {
		return errors.New(`"openapi" field must be a valid semantic version but not`)
	}

	infoBytes, ok := proxy["info"]
	if !ok {
		return errors.New(`"info" field is required`)
	}
	var infoVal Info
	if err := yaml.Unmarshal(infoBytes, &infoVal); err != nil {
		return err
	}
	v.info = &infoVal

	if serversBytes, ok := proxy["servers"]; ok {
		var serversVal []*Server
		if err := yaml.Unmarshal(serversBytes, &serversVal); err != nil {
			return err
		}
		v.servers = serversVal
	}

	pathsBytes, ok := proxy["paths"]
	if !ok {
		return errors.New(`"paths" field is required`)
	}
	var pathsVal Paths
	if err := yaml.Unmarshal(pathsBytes, &pathsVal); err != nil {
		return err
	}
	v.paths = &pathsVal

	if componentsBytes, ok := proxy["components"]; ok {
		var componentsVal Components
		if err := yaml.Unmarshal(componentsBytes, &componentsVal); err != nil {
			return err
		}
		v.components = &componentsVal
	}

	if securityBytes, ok := proxy["security"]; ok {
		var securityVal []*SecurityRequirement
		if err := yaml.Unmarshal(securityBytes, &securityVal); err != nil {
			return err
		}
		v.security = securityVal
	}

	if tagsBytes, ok := proxy["tags"]; ok {
		var tagsVal []*Tag
		if err := yaml.Unmarshal(tagsBytes, &tagsVal); err != nil {
			return err
		}
		v.tags = tagsVal
	}

	if externalDocsBytes, ok := proxy["externalDocs"]; ok {
		var externalDocsVal ExternalDocumentation
		if err := yaml.Unmarshal(externalDocsBytes, &externalDocsVal); err != nil {
			return err
		}
		v.externalDocs = &externalDocsVal
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *Info) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	titleBytes, ok := proxy["title"]
	if !ok {
		return errors.New(`"title" field is required`)
	}
	var titleVal string
	if err := yaml.Unmarshal(titleBytes, &titleVal); err != nil {
		return err
	}
	v.title = titleVal

	if descriptionBytes, ok := proxy["description"]; ok {
		var descriptionVal string
		if err := yaml.Unmarshal(descriptionBytes, &descriptionVal); err != nil {
			return err
		}
		v.description = descriptionVal
	}

	if termsOfServiceBytes, ok := proxy["termsOfService"]; ok {
		var termsOfServiceVal string
		if err := yaml.Unmarshal(termsOfServiceBytes, &termsOfServiceVal); err != nil {
			return err
		}
		v.termsOfService = termsOfServiceVal
	}

	if v.termsOfService != "" {
		if _, err := url.ParseRequestURI(v.termsOfService); err != nil {
			return err
		}
	}

	if contactBytes, ok := proxy["contact"]; ok {
		var contactVal Contact
		if err := yaml.Unmarshal(contactBytes, &contactVal); err != nil {
			return err
		}
		v.contact = &contactVal
	}

	if licenseBytes, ok := proxy["license"]; ok {
		var licenseVal License
		if err := yaml.Unmarshal(licenseBytes, &licenseVal); err != nil {
			return err
		}
		v.license = &licenseVal
	}

	versionBytes, ok := proxy["version"]
	if !ok {
		return errors.New(`"version" field is required`)
	}
	var versionVal string
	if err := yaml.Unmarshal(versionBytes, &versionVal); err != nil {
		return err
	}
	v.version = versionVal
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *Contact) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if nameBytes, ok := proxy["name"]; ok {
		var nameVal string
		if err := yaml.Unmarshal(nameBytes, &nameVal); err != nil {
			return err
		}
		v.name = nameVal
	}

	if urlBytes, ok := proxy["url"]; ok {
		var urlVal string
		if err := yaml.Unmarshal(urlBytes, &urlVal); err != nil {
			return err
		}
		v.url = urlVal
	}

	if v.url != "" {
		if _, err := url.ParseRequestURI(v.url); err != nil {
			return err
		}
	}

	if emailBytes, ok := proxy["email"]; ok {
		var emailVal string
		if err := yaml.Unmarshal(emailBytes, &emailVal); err != nil {
			return err
		}
		v.email = emailVal
	}

	if v.email != "" {

		if v.email != "" && !emailRegexp.MatchString(v.email) {
			return errors.New(`"email" field must be an email address`)
		}
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *License) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	nameBytes, ok := proxy["name"]
	if !ok {
		return errors.New(`"name" field is required`)
	}
	var nameVal string
	if err := yaml.Unmarshal(nameBytes, &nameVal); err != nil {
		return err
	}
	v.name = nameVal

	if urlBytes, ok := proxy["url"]; ok {
		var urlVal string
		if err := yaml.Unmarshal(urlBytes, &urlVal); err != nil {
			return err
		}
		v.url = urlVal
	}

	if v.url != "" {
		if _, err := url.ParseRequestURI(v.url); err != nil {
			return err
		}
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *Server) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	urlBytes, ok := proxy["url"]
	if !ok {
		return errors.New(`"url" field is required`)
	}
	var urlVal string
	if err := yaml.Unmarshal(urlBytes, &urlVal); err != nil {
		return err
	}
	v.url = urlVal

	if _, err := url.Parse(urlTemplateVarRegexp.ReplaceAllLiteralString(v.url, `1111`)); err != nil {
		return err
	}

	if descriptionBytes, ok := proxy["description"]; ok {
		var descriptionVal string
		if err := yaml.Unmarshal(descriptionBytes, &descriptionVal); err != nil {
			return err
		}
		v.description = descriptionVal
	}

	if variablesBytes, ok := proxy["variables"]; ok {
		var variablesVal map[string]*ServerVariable
		if err := yaml.Unmarshal(variablesBytes, &variablesVal); err != nil {
			return err
		}
		v.variables = variablesVal
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *ServerVariable) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if enumBytes, ok := proxy["enum"]; ok {
		var enumVal []string
		if err := yaml.Unmarshal(enumBytes, &enumVal); err != nil {
			return err
		}
		v.enum = enumVal
	}

	default_Bytes, ok := proxy["default"]
	if !ok {
		return errors.New(`"default" field is required`)
	}
	var default_Val string
	if err := yaml.Unmarshal(default_Bytes, &default_Val); err != nil {
		return err
	}
	v.default_ = default_Val

	if descriptionBytes, ok := proxy["description"]; ok {
		var descriptionVal string
		if err := yaml.Unmarshal(descriptionBytes, &descriptionVal); err != nil {
			return err
		}
		v.description = descriptionVal
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *Components) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if schemasBytes, ok := proxy["schemas"]; ok {
		var schemasVal map[string]*Schema
		if err := yaml.Unmarshal(schemasBytes, &schemasVal); err != nil {
			return err
		}
		v.schemas = schemasVal
	}

	if responsesBytes, ok := proxy["responses"]; ok {
		var responsesVal map[string]*Response
		if err := yaml.Unmarshal(responsesBytes, &responsesVal); err != nil {
			return err
		}
		v.responses = responsesVal
	}

	if parametersBytes, ok := proxy["parameters"]; ok {
		var parametersVal map[string]*Parameter
		if err := yaml.Unmarshal(parametersBytes, &parametersVal); err != nil {
			return err
		}
		v.parameters = parametersVal
	}

	if examplesBytes, ok := proxy["examples"]; ok {
		var examplesVal map[string]*Example
		if err := yaml.Unmarshal(examplesBytes, &examplesVal); err != nil {
			return err
		}
		v.examples = examplesVal
	}

	if requestBodiesBytes, ok := proxy["requestBodies"]; ok {
		var requestBodiesVal map[string]*RequestBody
		if err := yaml.Unmarshal(requestBodiesBytes, &requestBodiesVal); err != nil {
			return err
		}
		v.requestBodies = requestBodiesVal
	}

	if headersBytes, ok := proxy["headers"]; ok {
		var headersVal map[string]*Header
		if err := yaml.Unmarshal(headersBytes, &headersVal); err != nil {
			return err
		}
		v.headers = headersVal
	}

	if securitySchemesBytes, ok := proxy["securitySchemes"]; ok {
		var securitySchemesVal map[string]*SecurityScheme
		if err := yaml.Unmarshal(securitySchemesBytes, &securitySchemesVal); err != nil {
			return err
		}
		v.securitySchemes = securitySchemesVal
	}

	if linksBytes, ok := proxy["links"]; ok {
		var linksVal map[string]*Link
		if err := yaml.Unmarshal(linksBytes, &linksVal); err != nil {
			return err
		}
		v.links = linksVal
	}

	if callbacksBytes, ok := proxy["callbacks"]; ok {
		var callbacksVal map[string]*Callback
		if err := yaml.Unmarshal(callbacksBytes, &callbacksVal); err != nil {
			return err
		}
		v.callbacks = callbacksVal
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *Paths) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}
	paths := map[string]*PathItem{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "/") {
			continue
		}
		var pathsv PathItem
		if err := yaml.Unmarshal(val, &pathsv); err != nil {
			return err
		}
		paths[key] = &pathsv
	}
	if len(paths) != 0 {
		v.paths = paths
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *PathItem) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if summaryBytes, ok := proxy["summary"]; ok {
		var summaryVal string
		if err := yaml.Unmarshal(summaryBytes, &summaryVal); err != nil {
			return err
		}
		v.summary = summaryVal
	}

	if descriptionBytes, ok := proxy["description"]; ok {
		var descriptionVal string
		if err := yaml.Unmarshal(descriptionBytes, &descriptionVal); err != nil {
			return err
		}
		v.description = descriptionVal
	}

	if getBytes, ok := proxy["get"]; ok {
		var getVal Operation
		if err := yaml.Unmarshal(getBytes, &getVal); err != nil {
			return err
		}
		v.get = &getVal
	}

	if putBytes, ok := proxy["put"]; ok {
		var putVal Operation
		if err := yaml.Unmarshal(putBytes, &putVal); err != nil {
			return err
		}
		v.put = &putVal
	}

	if postBytes, ok := proxy["post"]; ok {
		var postVal Operation
		if err := yaml.Unmarshal(postBytes, &postVal); err != nil {
			return err
		}
		v.post = &postVal
	}

	if deleteBytes, ok := proxy["delete"]; ok {
		var deleteVal Operation
		if err := yaml.Unmarshal(deleteBytes, &deleteVal); err != nil {
			return err
		}
		v.delete = &deleteVal
	}

	if optionsBytes, ok := proxy["options"]; ok {
		var optionsVal Operation
		if err := yaml.Unmarshal(optionsBytes, &optionsVal); err != nil {
			return err
		}
		v.options = &optionsVal
	}

	if headBytes, ok := proxy["head"]; ok {
		var headVal Operation
		if err := yaml.Unmarshal(headBytes, &headVal); err != nil {
			return err
		}
		v.head = &headVal
	}

	if patchBytes, ok := proxy["patch"]; ok {
		var patchVal Operation
		if err := yaml.Unmarshal(patchBytes, &patchVal); err != nil {
			return err
		}
		v.patch = &patchVal
	}

	if traceBytes, ok := proxy["trace"]; ok {
		var traceVal Operation
		if err := yaml.Unmarshal(traceBytes, &traceVal); err != nil {
			return err
		}
		v.trace = &traceVal
	}

	if serversBytes, ok := proxy["servers"]; ok {
		var serversVal []*Server
		if err := yaml.Unmarshal(serversBytes, &serversVal); err != nil {
			return err
		}
		v.servers = serversVal
	}

	if parametersBytes, ok := proxy["parameters"]; ok {
		var parametersVal []*Parameter
		if err := yaml.Unmarshal(parametersBytes, &parametersVal); err != nil {
			return err
		}
		v.parameters = parametersVal
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *Operation) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if tagsBytes, ok := proxy["tags"]; ok {
		var tagsVal []string
		if err := yaml.Unmarshal(tagsBytes, &tagsVal); err != nil {
			return err
		}
		v.tags = tagsVal
	}

	if summaryBytes, ok := proxy["summary"]; ok {
		var summaryVal string
		if err := yaml.Unmarshal(summaryBytes, &summaryVal); err != nil {
			return err
		}
		v.summary = summaryVal
	}

	if descriptionBytes, ok := proxy["description"]; ok {
		var descriptionVal string
		if err := yaml.Unmarshal(descriptionBytes, &descriptionVal); err != nil {
			return err
		}
		v.description = descriptionVal
	}

	if externalDocsBytes, ok := proxy["externalDocs"]; ok {
		var externalDocsVal ExternalDocumentation
		if err := yaml.Unmarshal(externalDocsBytes, &externalDocsVal); err != nil {
			return err
		}
		v.externalDocs = &externalDocsVal
	}

	if operationIDBytes, ok := proxy["operationId"]; ok {
		var operationIDVal string
		if err := yaml.Unmarshal(operationIDBytes, &operationIDVal); err != nil {
			return err
		}
		v.operationID = operationIDVal
	}

	if parametersBytes, ok := proxy["parameters"]; ok {
		var parametersVal []*Parameter
		if err := yaml.Unmarshal(parametersBytes, &parametersVal); err != nil {
			return err
		}
		v.parameters = parametersVal
	}

	if requestBodyBytes, ok := proxy["requestBody"]; ok {
		var requestBodyVal RequestBody
		if err := yaml.Unmarshal(requestBodyBytes, &requestBodyVal); err != nil {
			return err
		}
		v.requestBody = &requestBodyVal
	}

	responsesBytes, ok := proxy["responses"]
	if !ok {
		return errors.New(`"responses" field is required`)
	}
	var responsesVal Responses
	if err := yaml.Unmarshal(responsesBytes, &responsesVal); err != nil {
		return err
	}
	v.responses = &responsesVal

	if callbacksBytes, ok := proxy["callbacks"]; ok {
		var callbacksVal map[string]*Callback
		if err := yaml.Unmarshal(callbacksBytes, &callbacksVal); err != nil {
			return err
		}
		v.callbacks = callbacksVal
	}

	if deprecatedBytes, ok := proxy["deprecated"]; ok {
		var deprecatedVal bool
		if err := yaml.Unmarshal(deprecatedBytes, &deprecatedVal); err != nil {
			return err
		}
		v.deprecated = deprecatedVal
	}

	if securityBytes, ok := proxy["security"]; ok {
		var securityVal []*SecurityRequirement
		if err := yaml.Unmarshal(securityBytes, &securityVal); err != nil {
			return err
		}
		v.security = securityVal
	}

	if serversBytes, ok := proxy["servers"]; ok {
		var serversVal []*Server
		if err := yaml.Unmarshal(serversBytes, &serversVal); err != nil {
			return err
		}
		v.servers = serversVal
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *ExternalDocumentation) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if descriptionBytes, ok := proxy["description"]; ok {
		var descriptionVal string
		if err := yaml.Unmarshal(descriptionBytes, &descriptionVal); err != nil {
			return err
		}
		v.description = descriptionVal
	}

	urlBytes, ok := proxy["url"]
	if !ok {
		return errors.New(`"url" field is required`)
	}
	var urlVal string
	if err := yaml.Unmarshal(urlBytes, &urlVal); err != nil {
		return err
	}
	v.url = urlVal

	if _, err := url.ParseRequestURI(v.url); err != nil {
		return err
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *Parameter) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	nameBytes, ok := proxy["name"]
	if !ok {
		return errors.New(`"name" field is required`)
	}
	var nameVal string
	if err := yaml.Unmarshal(nameBytes, &nameVal); err != nil {
		return err
	}
	v.name = nameVal

	inBytes, ok := proxy["in"]
	if !ok {
		return errors.New(`"in" field is required`)
	}
	var inVal string
	if err := yaml.Unmarshal(inBytes, &inVal); err != nil {
		return err
	}
	v.in = inVal

	if !isOneOf(v.in, []string{"query", "header", "path", "cookie"}) {
		return errors.New(`"in" field must be one of ["query", "header", "path", "cookie"]`)
	}

	if descriptionBytes, ok := proxy["description"]; ok {
		var descriptionVal string
		if err := yaml.Unmarshal(descriptionBytes, &descriptionVal); err != nil {
			return err
		}
		v.description = descriptionVal
	}

	if requiredBytes, ok := proxy["required"]; ok {
		var requiredVal bool
		if err := yaml.Unmarshal(requiredBytes, &requiredVal); err != nil {
			return err
		}
		v.required = requiredVal
	}

	if deprecatedBytes, ok := proxy["deprecated"]; ok {
		var deprecatedVal bool
		if err := yaml.Unmarshal(deprecatedBytes, &deprecatedVal); err != nil {
			return err
		}
		v.deprecated = deprecatedVal
	}

	if allowEmptyValueBytes, ok := proxy["allowEmptyValue"]; ok {
		var allowEmptyValueVal bool
		if err := yaml.Unmarshal(allowEmptyValueBytes, &allowEmptyValueVal); err != nil {
			return err
		}
		v.allowEmptyValue = allowEmptyValueVal
	}

	if styleBytes, ok := proxy["style"]; ok {
		var styleVal string
		if err := yaml.Unmarshal(styleBytes, &styleVal); err != nil {
			return err
		}
		v.style = styleVal
	}

	if explodeBytes, ok := proxy["explode"]; ok {
		var explodeVal bool
		if err := yaml.Unmarshal(explodeBytes, &explodeVal); err != nil {
			return err
		}
		v.explode = explodeVal
	}

	if allowReservedBytes, ok := proxy["allowReserved"]; ok {
		var allowReservedVal bool
		if err := yaml.Unmarshal(allowReservedBytes, &allowReservedVal); err != nil {
			return err
		}
		v.allowReserved = allowReservedVal
	}

	if schemaBytes, ok := proxy["schema"]; ok {
		var schemaVal Schema
		if err := yaml.Unmarshal(schemaBytes, &schemaVal); err != nil {
			return err
		}
		v.schema = &schemaVal
	}

	if exampleBytes, ok := proxy["example"]; ok {
		var exampleVal interface{}
		if err := yaml.Unmarshal(exampleBytes, &exampleVal); err != nil {
			return err
		}
		v.example = exampleVal
	}

	if examplesBytes, ok := proxy["examples"]; ok {
		var examplesVal map[string]*Example
		if err := yaml.Unmarshal(examplesBytes, &examplesVal); err != nil {
			return err
		}
		v.examples = examplesVal
	}

	if contentBytes, ok := proxy["content"]; ok {
		var contentVal map[string]*MediaType
		if err := yaml.Unmarshal(contentBytes, &contentVal); err != nil {
			return err
		}
		v.content = contentVal
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}

	if referenceBytes, ok := proxy["$ref"]; ok {
		var referenceVal string
		if err := yaml.Unmarshal(referenceBytes, &referenceVal); err != nil {
			return err
		}
		v.reference = referenceVal
	}
	return nil
}

func (v *RequestBody) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if descriptionBytes, ok := proxy["description"]; ok {
		var descriptionVal string
		if err := yaml.Unmarshal(descriptionBytes, &descriptionVal); err != nil {
			return err
		}
		v.description = descriptionVal
	}

	contentBytes, ok := proxy["content"]
	if !ok {
		return errors.New(`"content" field is required`)
	}
	var contentVal map[string]*MediaType
	if err := yaml.Unmarshal(contentBytes, &contentVal); err != nil {
		return err
	}
	v.content = contentVal

	if requiredBytes, ok := proxy["required"]; ok {
		var requiredVal bool
		if err := yaml.Unmarshal(requiredBytes, &requiredVal); err != nil {
			return err
		}
		v.required = requiredVal
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}

	if referenceBytes, ok := proxy["$ref"]; ok {
		var referenceVal string
		if err := yaml.Unmarshal(referenceBytes, &referenceVal); err != nil {
			return err
		}
		v.reference = referenceVal
	}
	return nil
}

func (v *MediaType) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if schemaBytes, ok := proxy["schema"]; ok {
		var schemaVal Schema
		if err := yaml.Unmarshal(schemaBytes, &schemaVal); err != nil {
			return err
		}
		v.schema = &schemaVal
	}

	if exampleBytes, ok := proxy["example"]; ok {
		var exampleVal interface{}
		if err := yaml.Unmarshal(exampleBytes, &exampleVal); err != nil {
			return err
		}
		v.example = exampleVal
	}

	if examplesBytes, ok := proxy["examples"]; ok {
		var examplesVal map[string]*Example
		if err := yaml.Unmarshal(examplesBytes, &examplesVal); err != nil {
			return err
		}
		v.examples = examplesVal
	}

	if encodingBytes, ok := proxy["encoding"]; ok {
		var encodingVal map[string]*Encoding
		if err := yaml.Unmarshal(encodingBytes, &encodingVal); err != nil {
			return err
		}
		v.encoding = encodingVal
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *Encoding) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if contentTypeBytes, ok := proxy["contentType"]; ok {
		var contentTypeVal string
		if err := yaml.Unmarshal(contentTypeBytes, &contentTypeVal); err != nil {
			return err
		}
		v.contentType = contentTypeVal
	}

	if headersBytes, ok := proxy["headers"]; ok {
		var headersVal map[string]*Header
		if err := yaml.Unmarshal(headersBytes, &headersVal); err != nil {
			return err
		}
		v.headers = headersVal
	}

	if styleBytes, ok := proxy["style"]; ok {
		var styleVal string
		if err := yaml.Unmarshal(styleBytes, &styleVal); err != nil {
			return err
		}
		v.style = styleVal
	}

	if explodeBytes, ok := proxy["explode"]; ok {
		var explodeVal string
		if err := yaml.Unmarshal(explodeBytes, &explodeVal); err != nil {
			return err
		}
		v.explode = explodeVal
	}

	if allowReservedBytes, ok := proxy["allowReserved"]; ok {
		var allowReservedVal bool
		if err := yaml.Unmarshal(allowReservedBytes, &allowReservedVal); err != nil {
			return err
		}
		v.allowReserved = allowReservedVal
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *Responses) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}
	responses := map[string]*Response{}
	for key, val := range proxy {
		responsesRegexp := regexp.MustCompile(`^[1-5]([0-9][0-9]|XX)|default$`)
		if !responsesRegexp.MatchString(key) {
			continue
		}
		var responsesv Response
		if err := yaml.Unmarshal(val, &responsesv); err != nil {
			return err
		}
		responses[key] = &responsesv
	}
	if len(responses) != 0 {
		v.responses = responses
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *Response) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	descriptionBytes, ok := proxy["description"]
	if !ok {
		return errors.New(`"description" field is required`)
	}
	var descriptionVal string
	if err := yaml.Unmarshal(descriptionBytes, &descriptionVal); err != nil {
		return err
	}
	v.description = descriptionVal

	if headersBytes, ok := proxy["headers"]; ok {
		var headersVal map[string]*Header
		if err := yaml.Unmarshal(headersBytes, &headersVal); err != nil {
			return err
		}
		v.headers = headersVal
	}

	if contentBytes, ok := proxy["content"]; ok {
		var contentVal map[string]*MediaType
		if err := yaml.Unmarshal(contentBytes, &contentVal); err != nil {
			return err
		}
		v.content = contentVal
	}

	if linksBytes, ok := proxy["links"]; ok {
		var linksVal map[string]*Link
		if err := yaml.Unmarshal(linksBytes, &linksVal); err != nil {
			return err
		}
		v.links = linksVal
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}

	if referenceBytes, ok := proxy["$ref"]; ok {
		var referenceVal string
		if err := yaml.Unmarshal(referenceBytes, &referenceVal); err != nil {
			return err
		}
		v.reference = referenceVal
	}
	return nil
}

func (v *Callback) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}
	callback := map[string]*PathItem{}
	for key, val := range proxy {
		var callbackv PathItem
		if err := yaml.Unmarshal(val, &callbackv); err != nil {
			return err
		}
		callback[key] = &callbackv
	}
	if len(callback) != 0 {
		v.callback = callback
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}

	if referenceBytes, ok := proxy["$ref"]; ok {
		var referenceVal string
		if err := yaml.Unmarshal(referenceBytes, &referenceVal); err != nil {
			return err
		}
		v.reference = referenceVal
	}
	return nil
}

func (v *Example) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if summaryBytes, ok := proxy["summary"]; ok {
		var summaryVal string
		if err := yaml.Unmarshal(summaryBytes, &summaryVal); err != nil {
			return err
		}
		v.summary = summaryVal
	}

	if descriptionBytes, ok := proxy["description"]; ok {
		var descriptionVal string
		if err := yaml.Unmarshal(descriptionBytes, &descriptionVal); err != nil {
			return err
		}
		v.description = descriptionVal
	}

	if valueBytes, ok := proxy["value"]; ok {
		var valueVal interface{}
		if err := yaml.Unmarshal(valueBytes, &valueVal); err != nil {
			return err
		}
		v.value = valueVal
	}

	if externalValueBytes, ok := proxy["externalValue"]; ok {
		var externalValueVal string
		if err := yaml.Unmarshal(externalValueBytes, &externalValueVal); err != nil {
			return err
		}
		v.externalValue = externalValueVal
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}

	if referenceBytes, ok := proxy["$ref"]; ok {
		var referenceVal string
		if err := yaml.Unmarshal(referenceBytes, &referenceVal); err != nil {
			return err
		}
		v.reference = referenceVal
	}
	return nil
}

func (v *Link) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if operationRefBytes, ok := proxy["operationRef"]; ok {
		var operationRefVal string
		if err := yaml.Unmarshal(operationRefBytes, &operationRefVal); err != nil {
			return err
		}
		v.operationRef = operationRefVal
	}

	if operationIDBytes, ok := proxy["operationId"]; ok {
		var operationIDVal string
		if err := yaml.Unmarshal(operationIDBytes, &operationIDVal); err != nil {
			return err
		}
		v.operationID = operationIDVal
	}

	if parametersBytes, ok := proxy["parameters"]; ok {
		var parametersVal map[string]interface{}
		if err := yaml.Unmarshal(parametersBytes, &parametersVal); err != nil {
			return err
		}
		v.parameters = parametersVal
	}

	if requestBodyBytes, ok := proxy["requestBody"]; ok {
		var requestBodyVal interface{}
		if err := yaml.Unmarshal(requestBodyBytes, &requestBodyVal); err != nil {
			return err
		}
		v.requestBody = requestBodyVal
	}

	if descriptionBytes, ok := proxy["description"]; ok {
		var descriptionVal string
		if err := yaml.Unmarshal(descriptionBytes, &descriptionVal); err != nil {
			return err
		}
		v.description = descriptionVal
	}

	if serverBytes, ok := proxy["server"]; ok {
		var serverVal Server
		if err := yaml.Unmarshal(serverBytes, &serverVal); err != nil {
			return err
		}
		v.server = &serverVal
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}

	if referenceBytes, ok := proxy["$ref"]; ok {
		var referenceVal string
		if err := yaml.Unmarshal(referenceBytes, &referenceVal); err != nil {
			return err
		}
		v.reference = referenceVal
	}
	return nil
}

func (v *Header) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if nameBytes, ok := proxy["name"]; ok {
		var nameVal string
		if err := yaml.Unmarshal(nameBytes, &nameVal); err != nil {
			return err
		}
		v.name = nameVal
	}

	if inBytes, ok := proxy["in"]; ok {
		var inVal string
		if err := yaml.Unmarshal(inBytes, &inVal); err != nil {
			return err
		}
		v.in = inVal
	}

	if descriptionBytes, ok := proxy["description"]; ok {
		var descriptionVal string
		if err := yaml.Unmarshal(descriptionBytes, &descriptionVal); err != nil {
			return err
		}
		v.description = descriptionVal
	}

	if requiredBytes, ok := proxy["required"]; ok {
		var requiredVal bool
		if err := yaml.Unmarshal(requiredBytes, &requiredVal); err != nil {
			return err
		}
		v.required = requiredVal
	}

	if deprecatedBytes, ok := proxy["deprecated"]; ok {
		var deprecatedVal bool
		if err := yaml.Unmarshal(deprecatedBytes, &deprecatedVal); err != nil {
			return err
		}
		v.deprecated = deprecatedVal
	}

	if allowEmptyValueBytes, ok := proxy["allowEmptyValue"]; ok {
		var allowEmptyValueVal bool
		if err := yaml.Unmarshal(allowEmptyValueBytes, &allowEmptyValueVal); err != nil {
			return err
		}
		v.allowEmptyValue = allowEmptyValueVal
	}

	if styleBytes, ok := proxy["style"]; ok {
		var styleVal string
		if err := yaml.Unmarshal(styleBytes, &styleVal); err != nil {
			return err
		}
		v.style = styleVal
	}

	if explodeBytes, ok := proxy["explode"]; ok {
		var explodeVal bool
		if err := yaml.Unmarshal(explodeBytes, &explodeVal); err != nil {
			return err
		}
		v.explode = explodeVal
	}

	if allowReservedBytes, ok := proxy["allowReserved"]; ok {
		var allowReservedVal bool
		if err := yaml.Unmarshal(allowReservedBytes, &allowReservedVal); err != nil {
			return err
		}
		v.allowReserved = allowReservedVal
	}

	if schemaBytes, ok := proxy["schema"]; ok {
		var schemaVal Schema
		if err := yaml.Unmarshal(schemaBytes, &schemaVal); err != nil {
			return err
		}
		v.schema = &schemaVal
	}

	if exampleBytes, ok := proxy["example"]; ok {
		var exampleVal interface{}
		if err := yaml.Unmarshal(exampleBytes, &exampleVal); err != nil {
			return err
		}
		v.example = exampleVal
	}

	if examplesBytes, ok := proxy["examples"]; ok {
		var examplesVal map[string]*Example
		if err := yaml.Unmarshal(examplesBytes, &examplesVal); err != nil {
			return err
		}
		v.examples = examplesVal
	}

	if contentBytes, ok := proxy["content"]; ok {
		var contentVal map[string]*MediaType
		if err := yaml.Unmarshal(contentBytes, &contentVal); err != nil {
			return err
		}
		v.content = contentVal
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}

	if referenceBytes, ok := proxy["$ref"]; ok {
		var referenceVal string
		if err := yaml.Unmarshal(referenceBytes, &referenceVal); err != nil {
			return err
		}
		v.reference = referenceVal
	}
	return nil
}

func (v *Tag) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	nameBytes, ok := proxy["name"]
	if !ok {
		return errors.New(`"name" field is required`)
	}
	var nameVal string
	if err := yaml.Unmarshal(nameBytes, &nameVal); err != nil {
		return err
	}
	v.name = nameVal

	if descriptionBytes, ok := proxy["description"]; ok {
		var descriptionVal string
		if err := yaml.Unmarshal(descriptionBytes, &descriptionVal); err != nil {
			return err
		}
		v.description = descriptionVal
	}

	if externalDocsBytes, ok := proxy["externalDocs"]; ok {
		var externalDocsVal ExternalDocumentation
		if err := yaml.Unmarshal(externalDocsBytes, &externalDocsVal); err != nil {
			return err
		}
		v.externalDocs = &externalDocsVal
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *Schema) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if titleBytes, ok := proxy["title"]; ok {
		var titleVal string
		if err := yaml.Unmarshal(titleBytes, &titleVal); err != nil {
			return err
		}
		v.title = titleVal
	}

	if multipleOfBytes, ok := proxy["multipleOf"]; ok {
		var multipleOfVal int
		if err := yaml.Unmarshal(multipleOfBytes, &multipleOfVal); err != nil {
			return err
		}
		v.multipleOf = multipleOfVal
	}

	if maximumBytes, ok := proxy["maximum"]; ok {
		var maximumVal int
		if err := yaml.Unmarshal(maximumBytes, &maximumVal); err != nil {
			return err
		}
		v.maximum = maximumVal
	}

	if exclusiveMaximumBytes, ok := proxy["exclusiveMaximum"]; ok {
		var exclusiveMaximumVal bool
		if err := yaml.Unmarshal(exclusiveMaximumBytes, &exclusiveMaximumVal); err != nil {
			return err
		}
		v.exclusiveMaximum = exclusiveMaximumVal
	}

	if minimumBytes, ok := proxy["minimum"]; ok {
		var minimumVal int
		if err := yaml.Unmarshal(minimumBytes, &minimumVal); err != nil {
			return err
		}
		v.minimum = minimumVal
	}

	if exclusiveMinimumBytes, ok := proxy["exclusiveMinimum"]; ok {
		var exclusiveMinimumVal bool
		if err := yaml.Unmarshal(exclusiveMinimumBytes, &exclusiveMinimumVal); err != nil {
			return err
		}
		v.exclusiveMinimum = exclusiveMinimumVal
	}

	if maxLengthBytes, ok := proxy["maxLength"]; ok {
		var maxLengthVal int
		if err := yaml.Unmarshal(maxLengthBytes, &maxLengthVal); err != nil {
			return err
		}
		v.maxLength = maxLengthVal
	}

	if minLengthBytes, ok := proxy["minLength"]; ok {
		var minLengthVal int
		if err := yaml.Unmarshal(minLengthBytes, &minLengthVal); err != nil {
			return err
		}
		v.minLength = minLengthVal
	}

	if patternBytes, ok := proxy["pattern"]; ok {
		var patternVal string
		if err := yaml.Unmarshal(patternBytes, &patternVal); err != nil {
			return err
		}
		v.pattern = patternVal
	}

	if maxItemsBytes, ok := proxy["maxItems"]; ok {
		var maxItemsVal int
		if err := yaml.Unmarshal(maxItemsBytes, &maxItemsVal); err != nil {
			return err
		}
		v.maxItems = maxItemsVal
	}

	if minItemsBytes, ok := proxy["minItems"]; ok {
		var minItemsVal int
		if err := yaml.Unmarshal(minItemsBytes, &minItemsVal); err != nil {
			return err
		}
		v.minItems = minItemsVal
	}

	if maxPropertiesBytes, ok := proxy["maxProperties"]; ok {
		var maxPropertiesVal int
		if err := yaml.Unmarshal(maxPropertiesBytes, &maxPropertiesVal); err != nil {
			return err
		}
		v.maxProperties = maxPropertiesVal
	}

	if minPropertiesBytes, ok := proxy["minProperties"]; ok {
		var minPropertiesVal int
		if err := yaml.Unmarshal(minPropertiesBytes, &minPropertiesVal); err != nil {
			return err
		}
		v.minProperties = minPropertiesVal
	}

	if requiredBytes, ok := proxy["required"]; ok {
		var requiredVal []string
		if err := yaml.Unmarshal(requiredBytes, &requiredVal); err != nil {
			return err
		}
		v.required = requiredVal
	}

	if enumBytes, ok := proxy["enum"]; ok {
		var enumVal []string
		if err := yaml.Unmarshal(enumBytes, &enumVal); err != nil {
			return err
		}
		v.enum = enumVal
	}

	if type_Bytes, ok := proxy["type"]; ok {
		var type_Val string
		if err := yaml.Unmarshal(type_Bytes, &type_Val); err != nil {
			return err
		}
		v.type_ = type_Val
	}

	if allOfBytes, ok := proxy["allOf"]; ok {
		var allOfVal []*Schema
		if err := yaml.Unmarshal(allOfBytes, &allOfVal); err != nil {
			return err
		}
		v.allOf = allOfVal
	}

	if oneOfBytes, ok := proxy["oneOf"]; ok {
		var oneOfVal []*Schema
		if err := yaml.Unmarshal(oneOfBytes, &oneOfVal); err != nil {
			return err
		}
		v.oneOf = oneOfVal
	}

	if anyOfBytes, ok := proxy["anyOf"]; ok {
		var anyOfVal []*Schema
		if err := yaml.Unmarshal(anyOfBytes, &anyOfVal); err != nil {
			return err
		}
		v.anyOf = anyOfVal
	}

	if notBytes, ok := proxy["not"]; ok {
		var notVal Schema
		if err := yaml.Unmarshal(notBytes, &notVal); err != nil {
			return err
		}
		v.not = &notVal
	}

	if itemsBytes, ok := proxy["items"]; ok {
		var itemsVal Schema
		if err := yaml.Unmarshal(itemsBytes, &itemsVal); err != nil {
			return err
		}
		v.items = &itemsVal
	}

	if propertiesBytes, ok := proxy["properties"]; ok {
		var propertiesVal map[string]*Schema
		if err := yaml.Unmarshal(propertiesBytes, &propertiesVal); err != nil {
			return err
		}
		v.properties = propertiesVal
	}

	if additionalPropertiesBytes, ok := proxy["additionalProperties"]; ok {
		var additionalPropertiesVal Schema
		if err := yaml.Unmarshal(additionalPropertiesBytes, &additionalPropertiesVal); err != nil {
			return err
		}
		v.additionalProperties = &additionalPropertiesVal
	}

	if descriptionBytes, ok := proxy["description"]; ok {
		var descriptionVal string
		if err := yaml.Unmarshal(descriptionBytes, &descriptionVal); err != nil {
			return err
		}
		v.description = descriptionVal
	}

	if formatBytes, ok := proxy["format"]; ok {
		var formatVal string
		if err := yaml.Unmarshal(formatBytes, &formatVal); err != nil {
			return err
		}
		v.format = formatVal
	}

	if default_Bytes, ok := proxy["default"]; ok {
		var default_Val string
		if err := yaml.Unmarshal(default_Bytes, &default_Val); err != nil {
			return err
		}
		v.default_ = default_Val
	}

	if nullableBytes, ok := proxy["nullable"]; ok {
		var nullableVal bool
		if err := yaml.Unmarshal(nullableBytes, &nullableVal); err != nil {
			return err
		}
		v.nullable = nullableVal
	}

	if discriminatorBytes, ok := proxy["discriminator"]; ok {
		var discriminatorVal Discriminator
		if err := yaml.Unmarshal(discriminatorBytes, &discriminatorVal); err != nil {
			return err
		}
		v.discriminator = &discriminatorVal
	}

	if readOnlyBytes, ok := proxy["readOnly"]; ok {
		var readOnlyVal bool
		if err := yaml.Unmarshal(readOnlyBytes, &readOnlyVal); err != nil {
			return err
		}
		v.readOnly = readOnlyVal
	}

	if writeOnlyBytes, ok := proxy["writeOnly"]; ok {
		var writeOnlyVal bool
		if err := yaml.Unmarshal(writeOnlyBytes, &writeOnlyVal); err != nil {
			return err
		}
		v.writeOnly = writeOnlyVal
	}

	if xmlBytes, ok := proxy["xml"]; ok {
		var xmlVal XML
		if err := yaml.Unmarshal(xmlBytes, &xmlVal); err != nil {
			return err
		}
		v.xml = &xmlVal
	}

	if externalDocsBytes, ok := proxy["externalDocs"]; ok {
		var externalDocsVal ExternalDocumentation
		if err := yaml.Unmarshal(externalDocsBytes, &externalDocsVal); err != nil {
			return err
		}
		v.externalDocs = &externalDocsVal
	}

	if exampleBytes, ok := proxy["example"]; ok {
		var exampleVal interface{}
		if err := yaml.Unmarshal(exampleBytes, &exampleVal); err != nil {
			return err
		}
		v.example = exampleVal
	}

	if deprecatedBytes, ok := proxy["deprecated"]; ok {
		var deprecatedVal bool
		if err := yaml.Unmarshal(deprecatedBytes, &deprecatedVal); err != nil {
			return err
		}
		v.deprecated = deprecatedVal
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}

	if referenceBytes, ok := proxy["$ref"]; ok {
		var referenceVal string
		if err := yaml.Unmarshal(referenceBytes, &referenceVal); err != nil {
			return err
		}
		v.reference = referenceVal
	}
	return nil
}

func (v *Discriminator) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if propertyNameBytes, ok := proxy["propertyName"]; ok {
		var propertyNameVal string
		if err := yaml.Unmarshal(propertyNameBytes, &propertyNameVal); err != nil {
			return err
		}
		v.propertyName = propertyNameVal
	}

	if mappingBytes, ok := proxy["mapping"]; ok {
		var mappingVal map[string]string
		if err := yaml.Unmarshal(mappingBytes, &mappingVal); err != nil {
			return err
		}
		v.mapping = mappingVal
	}
	return nil
}

func (v *XML) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if nameBytes, ok := proxy["name"]; ok {
		var nameVal string
		if err := yaml.Unmarshal(nameBytes, &nameVal); err != nil {
			return err
		}
		v.name = nameVal
	}

	if namespaceBytes, ok := proxy["namespace"]; ok {
		var namespaceVal string
		if err := yaml.Unmarshal(namespaceBytes, &namespaceVal); err != nil {
			return err
		}
		v.namespace = namespaceVal
	}

	if prefixBytes, ok := proxy["prefix"]; ok {
		var prefixVal string
		if err := yaml.Unmarshal(prefixBytes, &prefixVal); err != nil {
			return err
		}
		v.prefix = prefixVal
	}

	if attributeBytes, ok := proxy["attribute"]; ok {
		var attributeVal bool
		if err := yaml.Unmarshal(attributeBytes, &attributeVal); err != nil {
			return err
		}
		v.attribute = attributeVal
	}

	if wrappedBytes, ok := proxy["wrapped"]; ok {
		var wrappedVal bool
		if err := yaml.Unmarshal(wrappedBytes, &wrappedVal); err != nil {
			return err
		}
		v.wrapped = wrappedVal
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *SecurityScheme) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if type_Bytes, ok := proxy["type"]; ok {
		var type_Val string
		if err := yaml.Unmarshal(type_Bytes, &type_Val); err != nil {
			return err
		}
		v.type_ = type_Val
	}

	if v.type_ != "" {
		if !isOneOf(v.type_, []string{"apiKey", "http", "oauth2", "openIdConnect"}) {
			return errors.New(`"type" field must be one of ["apiKey", "http", "oauth2", "openIdConnect"]`)
		}
	}

	if descriptionBytes, ok := proxy["description"]; ok {
		var descriptionVal string
		if err := yaml.Unmarshal(descriptionBytes, &descriptionVal); err != nil {
			return err
		}
		v.description = descriptionVal
	}

	if nameBytes, ok := proxy["name"]; ok {
		var nameVal string
		if err := yaml.Unmarshal(nameBytes, &nameVal); err != nil {
			return err
		}
		v.name = nameVal
	}

	if inBytes, ok := proxy["in"]; ok {
		var inVal string
		if err := yaml.Unmarshal(inBytes, &inVal); err != nil {
			return err
		}
		v.in = inVal
	}

	if v.in != "" {
		if !isOneOf(v.in, []string{"query", "header", "cookie"}) {
			return errors.New(`"in" field must be one of ["query", "header", "cookie"]`)
		}
	}

	if schemeBytes, ok := proxy["scheme"]; ok {
		var schemeVal string
		if err := yaml.Unmarshal(schemeBytes, &schemeVal); err != nil {
			return err
		}
		v.scheme = schemeVal
	}

	if bearerFormatBytes, ok := proxy["bearerFormat"]; ok {
		var bearerFormatVal string
		if err := yaml.Unmarshal(bearerFormatBytes, &bearerFormatVal); err != nil {
			return err
		}
		v.bearerFormat = bearerFormatVal
	}

	if flowsBytes, ok := proxy["flows"]; ok {
		var flowsVal OAuthFlows
		if err := yaml.Unmarshal(flowsBytes, &flowsVal); err != nil {
			return err
		}
		v.flows = &flowsVal
	}

	if openIDConnectURLBytes, ok := proxy["openIdConnectUrl"]; ok {
		var openIDConnectURLVal string
		if err := yaml.Unmarshal(openIDConnectURLBytes, &openIDConnectURLVal); err != nil {
			return err
		}
		v.openIDConnectURL = openIDConnectURLVal
	}

	if v.openIDConnectURL != "" {
		if _, err := url.ParseRequestURI(v.openIDConnectURL); err != nil {
			return err
		}
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}

	if referenceBytes, ok := proxy["$ref"]; ok {
		var referenceVal string
		if err := yaml.Unmarshal(referenceBytes, &referenceVal); err != nil {
			return err
		}
		v.reference = referenceVal
	}
	return nil
}

func (v *OAuthFlows) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if implicitBytes, ok := proxy["implicit"]; ok {
		var implicitVal OAuthFlow
		if err := yaml.Unmarshal(implicitBytes, &implicitVal); err != nil {
			return err
		}
		v.implicit = &implicitVal
	}

	if passwordBytes, ok := proxy["password"]; ok {
		var passwordVal OAuthFlow
		if err := yaml.Unmarshal(passwordBytes, &passwordVal); err != nil {
			return err
		}
		v.password = &passwordVal
	}

	if clientCredentialsBytes, ok := proxy["clientCredentials"]; ok {
		var clientCredentialsVal OAuthFlow
		if err := yaml.Unmarshal(clientCredentialsBytes, &clientCredentialsVal); err != nil {
			return err
		}
		v.clientCredentials = &clientCredentialsVal
	}

	if authorizationCodeBytes, ok := proxy["authorizationCode"]; ok {
		var authorizationCodeVal OAuthFlow
		if err := yaml.Unmarshal(authorizationCodeBytes, &authorizationCodeVal); err != nil {
			return err
		}
		v.authorizationCode = &authorizationCodeVal
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *OAuthFlow) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if authorizationURLBytes, ok := proxy["authorizationUrl"]; ok {
		var authorizationURLVal string
		if err := yaml.Unmarshal(authorizationURLBytes, &authorizationURLVal); err != nil {
			return err
		}
		v.authorizationURL = authorizationURLVal
	}

	if v.authorizationURL != "" {
		if _, err := url.ParseRequestURI(v.authorizationURL); err != nil {
			return err
		}
	}

	if tokenURLBytes, ok := proxy["tokenUrl"]; ok {
		var tokenURLVal string
		if err := yaml.Unmarshal(tokenURLBytes, &tokenURLVal); err != nil {
			return err
		}
		v.tokenURL = tokenURLVal
	}

	if v.tokenURL != "" {
		if _, err := url.ParseRequestURI(v.tokenURL); err != nil {
			return err
		}
	}

	if refreshURLBytes, ok := proxy["refreshUrl"]; ok {
		var refreshURLVal string
		if err := yaml.Unmarshal(refreshURLBytes, &refreshURLVal); err != nil {
			return err
		}
		v.refreshURL = refreshURLVal
	}

	if v.refreshURL != "" {
		if _, err := url.ParseRequestURI(v.refreshURL); err != nil {
			return err
		}
	}

	if scopesBytes, ok := proxy["scopes"]; ok {
		var scopesVal map[string]string
		if err := yaml.Unmarshal(scopesBytes, &scopesVal); err != nil {
			return err
		}
		v.scopes = scopesVal
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *SecurityRequirement) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}
	securityRequirement := map[string][]string{}
	for key, val := range proxy {
		var securityRequirementv []string
		if err := yaml.Unmarshal(val, &securityRequirementv); err != nil {
			return err
		}
		securityRequirement[key] = securityRequirementv
	}
	if len(securityRequirement) != 0 {
		v.securityRequirement = securityRequirement
	}
	return nil
}
