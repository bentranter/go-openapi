// Code generated by mkunmarshalyaml.go. DO NOT EDIT.

package openapi

import (
	"errors"
	"net/url"
	"regexp"
	"strconv"
	"strings"

	yaml "github.com/goccy/go-yaml"
)

func (v *OpenAPI) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	openapiBytes, ok := proxy["openapi"]
	if !ok {
		return errors.New(`"openapi" field is required`)
	}
	v.openapi = string(openapiBytes)

	if !isValidSemVer(v.openapi) {
		return errors.New(`"openapi" field must be a valid semantic version but not`)
	}

	infoBytes, ok := proxy["info"]
	if !ok {
		return errors.New(`"info" field is required`)
	}
	var info Info
	if err := yaml.Unmarshal(infoBytes, &info); err != nil {
		return err
	}
	v.info = &info

	if serversBytes, ok := proxy["servers"]; ok {
		var servers []*Server
		if err := yaml.Unmarshal(serversBytes, &servers); err != nil {
			return err
		}
		v.servers = servers
	}

	pathsBytes, ok := proxy["paths"]
	if !ok {
		return errors.New(`"paths" field is required`)
	}
	var paths Paths
	if err := yaml.Unmarshal(pathsBytes, &paths); err != nil {
		return err
	}
	v.paths = &paths

	if componentsBytes, ok := proxy["components"]; ok {
		var components Components
		if err := yaml.Unmarshal(componentsBytes, &components); err != nil {
			return err
		}
		v.components = &components
	}

	if securityBytes, ok := proxy["security"]; ok {
		var security []*SecurityRequirement
		if err := yaml.Unmarshal(securityBytes, &security); err != nil {
			return err
		}
		v.security = security
	}

	if tagsBytes, ok := proxy["tags"]; ok {
		var tags []*Tag
		if err := yaml.Unmarshal(tagsBytes, &tags); err != nil {
			return err
		}
		v.tags = tags
	}

	if externalDocsBytes, ok := proxy["externalDocs"]; ok {
		var externalDocs ExternalDocumentation
		if err := yaml.Unmarshal(externalDocsBytes, &externalDocs); err != nil {
			return err
		}
		v.externalDocs = &externalDocs
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *Info) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	titleBytes, ok := proxy["title"]
	if !ok {
		return errors.New(`"title" field is required`)
	}
	v.title = string(titleBytes)

	if descriptionBytes, ok := proxy["description"]; ok {
		v.description = string(descriptionBytes)
	}

	if termsOfServiceBytes, ok := proxy["termsOfService"]; ok {
		v.termsOfService = string(termsOfServiceBytes)
	}

	if v.termsOfService != "" {
		if _, err := url.ParseRequestURI(v.termsOfService); err != nil {
			return err
		}
	}

	if contactBytes, ok := proxy["contact"]; ok {
		var contact Contact
		if err := yaml.Unmarshal(contactBytes, &contact); err != nil {
			return err
		}
		v.contact = &contact
	}

	if licenseBytes, ok := proxy["license"]; ok {
		var license License
		if err := yaml.Unmarshal(licenseBytes, &license); err != nil {
			return err
		}
		v.license = &license
	}

	versionBytes, ok := proxy["version"]
	if !ok {
		return errors.New(`"version" field is required`)
	}
	v.version = string(versionBytes)
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *Contact) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if nameBytes, ok := proxy["name"]; ok {
		v.name = string(nameBytes)
	}

	if urlBytes, ok := proxy["url"]; ok {
		v.url = string(urlBytes)
	}

	if v.url != "" {
		if _, err := url.ParseRequestURI(v.url); err != nil {
			return err
		}
	}

	if emailBytes, ok := proxy["email"]; ok {
		v.email = string(emailBytes)
	}

	if v.email != "" {

		if v.email != "" && !emailRegexp.MatchString(v.email) {
			return errors.New(`"email" field must be an email address`)
		}
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *License) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	nameBytes, ok := proxy["name"]
	if !ok {
		return errors.New(`"name" field is required`)
	}
	v.name = string(nameBytes)

	if urlBytes, ok := proxy["url"]; ok {
		v.url = string(urlBytes)
	}

	if v.url != "" {
		if _, err := url.ParseRequestURI(v.url); err != nil {
			return err
		}
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *Server) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	urlBytes, ok := proxy["url"]
	if !ok {
		return errors.New(`"url" field is required`)
	}
	v.url = string(urlBytes)

	if _, err := url.Parse(urlTemplateVarRegexp.ReplaceAllLiteralString(v.url, `placeholder`)); err != nil {
		return err
	}

	if descriptionBytes, ok := proxy["description"]; ok {
		v.description = string(descriptionBytes)
	}

	if variablesBytes, ok := proxy["variables"]; ok {
		var variables map[string]*ServerVariable
		if err := yaml.Unmarshal(variablesBytes, &variables); err != nil {
			return err
		}
		v.variables = variables
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *ServerVariable) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if enumBytes, ok := proxy["enum"]; ok {
		var enum []string
		if err := yaml.Unmarshal(enumBytes, &enum); err != nil {
			return err
		}
		v.enum = enum
	}

	default_Bytes, ok := proxy["default"]
	if !ok {
		return errors.New(`"default" field is required`)
	}
	v.default_ = string(default_Bytes)

	if descriptionBytes, ok := proxy["description"]; ok {
		v.description = string(descriptionBytes)
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *Components) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if schemasBytes, ok := proxy["schemas"]; ok {
		var schemas map[string]*Schema
		if err := yaml.Unmarshal(schemasBytes, &schemas); err != nil {
			return err
		}
		v.schemas = schemas
	}

	if responsesBytes, ok := proxy["responses"]; ok {
		var responses map[string]*Response
		if err := yaml.Unmarshal(responsesBytes, &responses); err != nil {
			return err
		}
		v.responses = responses
	}

	if parametersBytes, ok := proxy["parameters"]; ok {
		var parameters map[string]*Parameter
		if err := yaml.Unmarshal(parametersBytes, &parameters); err != nil {
			return err
		}
		v.parameters = parameters
	}

	if examplesBytes, ok := proxy["examples"]; ok {
		var examples map[string]*Example
		if err := yaml.Unmarshal(examplesBytes, &examples); err != nil {
			return err
		}
		v.examples = examples
	}

	if requestBodiesBytes, ok := proxy["requestBodies"]; ok {
		var requestBodies map[string]*RequestBody
		if err := yaml.Unmarshal(requestBodiesBytes, &requestBodies); err != nil {
			return err
		}
		v.requestBodies = requestBodies
	}

	if headersBytes, ok := proxy["headers"]; ok {
		var headers map[string]*Header
		if err := yaml.Unmarshal(headersBytes, &headers); err != nil {
			return err
		}
		v.headers = headers
	}

	if securitySchemesBytes, ok := proxy["securitySchemes"]; ok {
		var securitySchemes map[string]*SecurityScheme
		if err := yaml.Unmarshal(securitySchemesBytes, &securitySchemes); err != nil {
			return err
		}
		v.securitySchemes = securitySchemes
	}

	if linksBytes, ok := proxy["links"]; ok {
		var links map[string]*Link
		if err := yaml.Unmarshal(linksBytes, &links); err != nil {
			return err
		}
		v.links = links
	}

	if callbacksBytes, ok := proxy["callbacks"]; ok {
		var callbacks map[string]*Callback
		if err := yaml.Unmarshal(callbacksBytes, &callbacks); err != nil {
			return err
		}
		v.callbacks = callbacks
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *Paths) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}
	paths := map[string]*PathItem{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "/") {
			continue
		}
		var pathsv PathItem
		if err := yaml.Unmarshal(val, &pathsv); err != nil {
			return err
		}
		paths[key] = &pathsv
	}
	if len(paths) != 0 {
		v.paths = paths
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *PathItem) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if summaryBytes, ok := proxy["summary"]; ok {
		v.summary = string(summaryBytes)
	}

	if descriptionBytes, ok := proxy["description"]; ok {
		v.description = string(descriptionBytes)
	}

	if getBytes, ok := proxy["get"]; ok {
		var get Operation
		if err := yaml.Unmarshal(getBytes, &get); err != nil {
			return err
		}
		v.get = &get
	}

	if putBytes, ok := proxy["put"]; ok {
		var put Operation
		if err := yaml.Unmarshal(putBytes, &put); err != nil {
			return err
		}
		v.put = &put
	}

	if postBytes, ok := proxy["post"]; ok {
		var post Operation
		if err := yaml.Unmarshal(postBytes, &post); err != nil {
			return err
		}
		v.post = &post
	}

	if deleteBytes, ok := proxy["delete"]; ok {
		var delete Operation
		if err := yaml.Unmarshal(deleteBytes, &delete); err != nil {
			return err
		}
		v.delete = &delete
	}

	if optionsBytes, ok := proxy["options"]; ok {
		var options Operation
		if err := yaml.Unmarshal(optionsBytes, &options); err != nil {
			return err
		}
		v.options = &options
	}

	if headBytes, ok := proxy["head"]; ok {
		var head Operation
		if err := yaml.Unmarshal(headBytes, &head); err != nil {
			return err
		}
		v.head = &head
	}

	if patchBytes, ok := proxy["patch"]; ok {
		var patch Operation
		if err := yaml.Unmarshal(patchBytes, &patch); err != nil {
			return err
		}
		v.patch = &patch
	}

	if traceBytes, ok := proxy["trace"]; ok {
		var trace Operation
		if err := yaml.Unmarshal(traceBytes, &trace); err != nil {
			return err
		}
		v.trace = &trace
	}

	if serversBytes, ok := proxy["servers"]; ok {
		var servers []*Server
		if err := yaml.Unmarshal(serversBytes, &servers); err != nil {
			return err
		}
		v.servers = servers
	}

	if parametersBytes, ok := proxy["parameters"]; ok {
		var parameters []*Parameter
		if err := yaml.Unmarshal(parametersBytes, &parameters); err != nil {
			return err
		}
		v.parameters = parameters
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *Operation) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if tagsBytes, ok := proxy["tags"]; ok {
		var tags []string
		if err := yaml.Unmarshal(tagsBytes, &tags); err != nil {
			return err
		}
		v.tags = tags
	}

	if summaryBytes, ok := proxy["summary"]; ok {
		v.summary = string(summaryBytes)
	}

	if descriptionBytes, ok := proxy["description"]; ok {
		v.description = string(descriptionBytes)
	}

	if externalDocsBytes, ok := proxy["externalDocs"]; ok {
		var externalDocs ExternalDocumentation
		if err := yaml.Unmarshal(externalDocsBytes, &externalDocs); err != nil {
			return err
		}
		v.externalDocs = &externalDocs
	}

	if operationIDBytes, ok := proxy["operationID"]; ok {
		v.operationID = string(operationIDBytes)
	}

	if parametersBytes, ok := proxy["parameters"]; ok {
		var parameters Parameter
		if err := yaml.Unmarshal(parametersBytes, &parameters); err != nil {
			return err
		}
		v.parameters = &parameters
	}

	if requestBodyBytes, ok := proxy["requestBody"]; ok {
		var requestBody RequestBody
		if err := yaml.Unmarshal(requestBodyBytes, &requestBody); err != nil {
			return err
		}
		v.requestBody = &requestBody
	}

	responsesBytes, ok := proxy["responses"]
	if !ok {
		return errors.New(`"responses" field is required`)
	}
	var responses Responses
	if err := yaml.Unmarshal(responsesBytes, &responses); err != nil {
		return err
	}
	v.responses = &responses

	if callbacksBytes, ok := proxy["callbacks"]; ok {
		var callbacks map[string]*Callback
		if err := yaml.Unmarshal(callbacksBytes, &callbacks); err != nil {
			return err
		}
		v.callbacks = callbacks
	}

	if deprecatedBytes, ok := proxy["deprecated"]; ok {
		t, err := strconv.ParseBool(string(deprecatedBytes))
		if err != nil {
			return err
		}
		v.deprecated = t
	}

	if securityBytes, ok := proxy["security"]; ok {
		var security []*SecurityRequirement
		if err := yaml.Unmarshal(securityBytes, &security); err != nil {
			return err
		}
		v.security = security
	}

	if serversBytes, ok := proxy["servers"]; ok {
		var servers []*Server
		if err := yaml.Unmarshal(serversBytes, &servers); err != nil {
			return err
		}
		v.servers = servers
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *ExternalDocumentation) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if descriptionBytes, ok := proxy["description"]; ok {
		v.description = string(descriptionBytes)
	}

	urlBytes, ok := proxy["url"]
	if !ok {
		return errors.New(`"url" field is required`)
	}
	v.url = string(urlBytes)

	if _, err := url.ParseRequestURI(v.url); err != nil {
		return err
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *Parameter) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	nameBytes, ok := proxy["name"]
	if !ok {
		return errors.New(`"name" field is required`)
	}
	v.name = string(nameBytes)

	inBytes, ok := proxy["in"]
	if !ok {
		return errors.New(`"in" field is required`)
	}
	v.in = string(inBytes)

	if isOneOf(v.in, []string{"query", "header", "path", "cookie"}) {
		return errors.New(`"in" field must be one of ["query", "header", "path", "cookie"]`)
	}

	if descriptionBytes, ok := proxy["description"]; ok {
		v.description = string(descriptionBytes)
	}

	if requiredBytes, ok := proxy["required"]; ok {
		t, err := strconv.ParseBool(string(requiredBytes))
		if err != nil {
			return err
		}
		v.required = t
	}

	if deprecatedBytes, ok := proxy["deprecated"]; ok {
		t, err := strconv.ParseBool(string(deprecatedBytes))
		if err != nil {
			return err
		}
		v.deprecated = t
	}

	if allowEmptyValueBytes, ok := proxy["allowEmptyValue"]; ok {
		t, err := strconv.ParseBool(string(allowEmptyValueBytes))
		if err != nil {
			return err
		}
		v.allowEmptyValue = t
	}

	if styleBytes, ok := proxy["style"]; ok {
		v.style = string(styleBytes)
	}

	if explodeBytes, ok := proxy["explode"]; ok {
		t, err := strconv.ParseBool(string(explodeBytes))
		if err != nil {
			return err
		}
		v.explode = t
	}

	if allowReservedBytes, ok := proxy["allowReserved"]; ok {
		t, err := strconv.ParseBool(string(allowReservedBytes))
		if err != nil {
			return err
		}
		v.allowReserved = t
	}

	if schemaBytes, ok := proxy["schema"]; ok {
		var schema Schema
		if err := yaml.Unmarshal(schemaBytes, &schema); err != nil {
			return err
		}
		v.schema = &schema
	}

	if exampleBytes, ok := proxy["example"]; ok {
		var example interface{}
		if err := yaml.Unmarshal(exampleBytes, &example); err != nil {
			return err
		}
		v.example = example
	}

	if examplesBytes, ok := proxy["examples"]; ok {
		var examples map[string]*Example
		if err := yaml.Unmarshal(examplesBytes, &examples); err != nil {
			return err
		}
		v.examples = examples
	}

	if contentBytes, ok := proxy["content"]; ok {
		var content map[string]*MediaType
		if err := yaml.Unmarshal(contentBytes, &content); err != nil {
			return err
		}
		v.content = content
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}

	if referenceBytes, ok := proxy["$ref"]; ok {
		v.reference = string(referenceBytes)
	}
	return nil
}

func (v *RequestBody) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if descriptionBytes, ok := proxy["description"]; ok {
		v.description = string(descriptionBytes)
	}

	contentBytes, ok := proxy["content"]
	if !ok {
		return errors.New(`"content" field is required`)
	}
	var content map[string]*MediaType
	if err := yaml.Unmarshal(contentBytes, &content); err != nil {
		return err
	}
	v.content = content

	if requiredBytes, ok := proxy["required"]; ok {
		t, err := strconv.ParseBool(string(requiredBytes))
		if err != nil {
			return err
		}
		v.required = t
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}

	if referenceBytes, ok := proxy["$ref"]; ok {
		v.reference = string(referenceBytes)
	}
	return nil
}

func (v *MediaType) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if schemaBytes, ok := proxy["schema"]; ok {
		var schema Schema
		if err := yaml.Unmarshal(schemaBytes, &schema); err != nil {
			return err
		}
		v.schema = &schema
	}

	if exampleBytes, ok := proxy["example"]; ok {
		var example interface{}
		if err := yaml.Unmarshal(exampleBytes, &example); err != nil {
			return err
		}
		v.example = example
	}

	if examplesBytes, ok := proxy["examples"]; ok {
		var examples map[string]*Example
		if err := yaml.Unmarshal(examplesBytes, &examples); err != nil {
			return err
		}
		v.examples = examples
	}

	if encodingBytes, ok := proxy["encoding"]; ok {
		var encoding map[string]*Encoding
		if err := yaml.Unmarshal(encodingBytes, &encoding); err != nil {
			return err
		}
		v.encoding = encoding
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *Encoding) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if contentTypeBytes, ok := proxy["contentType"]; ok {
		v.contentType = string(contentTypeBytes)
	}

	if headersBytes, ok := proxy["headers"]; ok {
		var headers map[string]*Header
		if err := yaml.Unmarshal(headersBytes, &headers); err != nil {
			return err
		}
		v.headers = headers
	}

	if styleBytes, ok := proxy["style"]; ok {
		v.style = string(styleBytes)
	}

	if explodeBytes, ok := proxy["explode"]; ok {
		v.explode = string(explodeBytes)
	}

	if allowReservedBytes, ok := proxy["allowReserved"]; ok {
		t, err := strconv.ParseBool(string(allowReservedBytes))
		if err != nil {
			return err
		}
		v.allowReserved = t
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *Responses) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}
	responses := map[string]*Response{}
	for key, val := range proxy {
		responsesRegexp := regexp.MustCompile(`^[1-5]([0-9][0-9]|XX)|default$`)
		if !responsesRegexp.MatchString(key) {
			continue
		}
		var responsesv Response
		if err := yaml.Unmarshal(val, &responsesv); err != nil {
			return err
		}
		responses[key] = &responsesv
	}
	if len(responses) != 0 {
		v.responses = responses
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *Response) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	descriptionBytes, ok := proxy["description"]
	if !ok {
		return errors.New(`"description" field is required`)
	}
	v.description = string(descriptionBytes)

	if headersBytes, ok := proxy["headers"]; ok {
		var headers map[string]*Header
		if err := yaml.Unmarshal(headersBytes, &headers); err != nil {
			return err
		}
		v.headers = headers
	}

	if contentBytes, ok := proxy["content"]; ok {
		var content map[string]*MediaType
		if err := yaml.Unmarshal(contentBytes, &content); err != nil {
			return err
		}
		v.content = content
	}

	if linksBytes, ok := proxy["links"]; ok {
		var links map[string]*Link
		if err := yaml.Unmarshal(linksBytes, &links); err != nil {
			return err
		}
		v.links = links
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}

	if referenceBytes, ok := proxy["$ref"]; ok {
		v.reference = string(referenceBytes)
	}
	return nil
}

func (v *Callback) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if callbackBytes, ok := proxy["callback"]; ok {
		var callback map[string]*PathItem
		if err := yaml.Unmarshal(callbackBytes, &callback); err != nil {
			return err
		}
		v.callback = callback
	}

	for key := range v.callback {
		if !matchRuntimeExpr(key) {
			return errors.New(`the keys of "callback" must be a runtime expression`)
		}
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}

	if referenceBytes, ok := proxy["$ref"]; ok {
		v.reference = string(referenceBytes)
	}
	return nil
}

func (v *Example) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if summaryBytes, ok := proxy["summary"]; ok {
		v.summary = string(summaryBytes)
	}

	if descriptionBytes, ok := proxy["description"]; ok {
		v.description = string(descriptionBytes)
	}

	if valueBytes, ok := proxy["value"]; ok {
		var value interface{}
		if err := yaml.Unmarshal(valueBytes, &value); err != nil {
			return err
		}
		v.value = value
	}

	if externalValeBytes, ok := proxy["externalVale"]; ok {
		v.externalVale = string(externalValeBytes)
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}

	if referenceBytes, ok := proxy["$ref"]; ok {
		v.reference = string(referenceBytes)
	}
	return nil
}

func (v *Link) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if operationreferenceBytes, ok := proxy["operationreference"]; ok {
		v.operationreference = string(operationreferenceBytes)
	}

	if operationIDBytes, ok := proxy["operationId"]; ok {
		v.operationID = string(operationIDBytes)
	}

	if parametersBytes, ok := proxy["parameters"]; ok {
		var parameters map[string]interface{}
		if err := yaml.Unmarshal(parametersBytes, &parameters); err != nil {
			return err
		}
		v.parameters = parameters
	}

	if requestBodyBytes, ok := proxy["requestBody"]; ok {
		var requestBody interface{}
		if err := yaml.Unmarshal(requestBodyBytes, &requestBody); err != nil {
			return err
		}
		v.requestBody = requestBody
	}

	if descriptionBytes, ok := proxy["description"]; ok {
		v.description = string(descriptionBytes)
	}

	if serverBytes, ok := proxy["server"]; ok {
		var server Server
		if err := yaml.Unmarshal(serverBytes, &server); err != nil {
			return err
		}
		v.server = &server
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}

	if referenceBytes, ok := proxy["$ref"]; ok {
		v.reference = string(referenceBytes)
	}
	return nil
}

func (v *Header) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if nameBytes, ok := proxy["name"]; ok {
		v.name = string(nameBytes)
	}

	if inBytes, ok := proxy["in"]; ok {
		v.in = string(inBytes)
	}

	if descriptionBytes, ok := proxy["description"]; ok {
		v.description = string(descriptionBytes)
	}

	if requiredBytes, ok := proxy["required"]; ok {
		t, err := strconv.ParseBool(string(requiredBytes))
		if err != nil {
			return err
		}
		v.required = t
	}

	if deprecatedBytes, ok := proxy["deprecated"]; ok {
		t, err := strconv.ParseBool(string(deprecatedBytes))
		if err != nil {
			return err
		}
		v.deprecated = t
	}

	if allowEmptyValueBytes, ok := proxy["allowEmptyValue"]; ok {
		t, err := strconv.ParseBool(string(allowEmptyValueBytes))
		if err != nil {
			return err
		}
		v.allowEmptyValue = t
	}

	if styleBytes, ok := proxy["style"]; ok {
		v.style = string(styleBytes)
	}

	if explodeBytes, ok := proxy["explode"]; ok {
		t, err := strconv.ParseBool(string(explodeBytes))
		if err != nil {
			return err
		}
		v.explode = t
	}

	if allowReservedBytes, ok := proxy["allowReserved"]; ok {
		t, err := strconv.ParseBool(string(allowReservedBytes))
		if err != nil {
			return err
		}
		v.allowReserved = t
	}

	if schemaBytes, ok := proxy["schema"]; ok {
		var schema Schema
		if err := yaml.Unmarshal(schemaBytes, &schema); err != nil {
			return err
		}
		v.schema = &schema
	}

	if exampleBytes, ok := proxy["example"]; ok {
		var example interface{}
		if err := yaml.Unmarshal(exampleBytes, &example); err != nil {
			return err
		}
		v.example = example
	}

	if examplesBytes, ok := proxy["examples"]; ok {
		var examples map[string]*Example
		if err := yaml.Unmarshal(examplesBytes, &examples); err != nil {
			return err
		}
		v.examples = examples
	}

	if contentBytes, ok := proxy["content"]; ok {
		var content map[string]*MediaType
		if err := yaml.Unmarshal(contentBytes, &content); err != nil {
			return err
		}
		v.content = content
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}

	if referenceBytes, ok := proxy["$ref"]; ok {
		v.reference = string(referenceBytes)
	}
	return nil
}

func (v *Tag) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	nameBytes, ok := proxy["name"]
	if !ok {
		return errors.New(`"name" field is required`)
	}
	v.name = string(nameBytes)

	if descriptionBytes, ok := proxy["description"]; ok {
		v.description = string(descriptionBytes)
	}

	if externalDocsBytes, ok := proxy["externalDocs"]; ok {
		var externalDocs ExternalDocumentation
		if err := yaml.Unmarshal(externalDocsBytes, &externalDocs); err != nil {
			return err
		}
		v.externalDocs = &externalDocs
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *Schema) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if titleBytes, ok := proxy["title"]; ok {
		v.title = string(titleBytes)
	}

	if multipleOfBytes, ok := proxy["multipleOf"]; ok {
		i, err := strconv.Atoi(string(multipleOfBytes))
		if err != nil {
			return err
		}
		v.multipleOf = i
	}

	if maximumBytes, ok := proxy["maximum"]; ok {
		i, err := strconv.Atoi(string(maximumBytes))
		if err != nil {
			return err
		}
		v.maximum = i
	}

	if exclusiveMaximumBytes, ok := proxy["exclusiveMaximum"]; ok {
		t, err := strconv.ParseBool(string(exclusiveMaximumBytes))
		if err != nil {
			return err
		}
		v.exclusiveMaximum = t
	}

	if minimumBytes, ok := proxy["minimum"]; ok {
		i, err := strconv.Atoi(string(minimumBytes))
		if err != nil {
			return err
		}
		v.minimum = i
	}

	if exclusiveMinimumBytes, ok := proxy["exclusiveMinimum"]; ok {
		t, err := strconv.ParseBool(string(exclusiveMinimumBytes))
		if err != nil {
			return err
		}
		v.exclusiveMinimum = t
	}

	if maxLengthBytes, ok := proxy["maxLength"]; ok {
		i, err := strconv.Atoi(string(maxLengthBytes))
		if err != nil {
			return err
		}
		v.maxLength = i
	}

	if minLengthBytes, ok := proxy["minLength"]; ok {
		i, err := strconv.Atoi(string(minLengthBytes))
		if err != nil {
			return err
		}
		v.minLength = i
	}

	if patternBytes, ok := proxy["pattern"]; ok {
		v.pattern = string(patternBytes)
	}

	if maxItemsBytes, ok := proxy["maxItems"]; ok {
		i, err := strconv.Atoi(string(maxItemsBytes))
		if err != nil {
			return err
		}
		v.maxItems = i
	}

	if minItemsBytes, ok := proxy["minItems"]; ok {
		i, err := strconv.Atoi(string(minItemsBytes))
		if err != nil {
			return err
		}
		v.minItems = i
	}

	if maxPropertiesBytes, ok := proxy["maxProperties"]; ok {
		i, err := strconv.Atoi(string(maxPropertiesBytes))
		if err != nil {
			return err
		}
		v.maxProperties = i
	}

	if minPropertiesBytes, ok := proxy["minProperties"]; ok {
		i, err := strconv.Atoi(string(minPropertiesBytes))
		if err != nil {
			return err
		}
		v.minProperties = i
	}

	if requiredBytes, ok := proxy["required"]; ok {
		var required []string
		if err := yaml.Unmarshal(requiredBytes, &required); err != nil {
			return err
		}
		v.required = required
	}

	if enumBytes, ok := proxy["enum"]; ok {
		var enum []string
		if err := yaml.Unmarshal(enumBytes, &enum); err != nil {
			return err
		}
		v.enum = enum
	}

	if type_Bytes, ok := proxy["type"]; ok {
		v.type_ = string(type_Bytes)
	}

	if allOfBytes, ok := proxy["allOf"]; ok {
		var allOf []*Schema
		if err := yaml.Unmarshal(allOfBytes, &allOf); err != nil {
			return err
		}
		v.allOf = allOf
	}

	if oneOfBytes, ok := proxy["oneOf"]; ok {
		var oneOf []*Schema
		if err := yaml.Unmarshal(oneOfBytes, &oneOf); err != nil {
			return err
		}
		v.oneOf = oneOf
	}

	if anyOfBytes, ok := proxy["anyOf"]; ok {
		var anyOf []*Schema
		if err := yaml.Unmarshal(anyOfBytes, &anyOf); err != nil {
			return err
		}
		v.anyOf = anyOf
	}

	if notBytes, ok := proxy["not"]; ok {
		var not Schema
		if err := yaml.Unmarshal(notBytes, &not); err != nil {
			return err
		}
		v.not = &not
	}

	if itemsBytes, ok := proxy["items"]; ok {
		var items Schema
		if err := yaml.Unmarshal(itemsBytes, &items); err != nil {
			return err
		}
		v.items = &items
	}

	if propertiesBytes, ok := proxy["properties"]; ok {
		var properties map[string]*Schema
		if err := yaml.Unmarshal(propertiesBytes, &properties); err != nil {
			return err
		}
		v.properties = properties
	}

	if additionalPropertiesBytes, ok := proxy["additionalProperties"]; ok {
		var additionalProperties Schema
		if err := yaml.Unmarshal(additionalPropertiesBytes, &additionalProperties); err != nil {
			return err
		}
		v.additionalProperties = &additionalProperties
	}

	if descriptionBytes, ok := proxy["description"]; ok {
		v.description = string(descriptionBytes)
	}

	if formatBytes, ok := proxy["format"]; ok {
		v.format = string(formatBytes)
	}

	if default_Bytes, ok := proxy["default"]; ok {
		v.default_ = string(default_Bytes)
	}

	if nullableBytes, ok := proxy["nullable"]; ok {
		t, err := strconv.ParseBool(string(nullableBytes))
		if err != nil {
			return err
		}
		v.nullable = t
	}

	if discriminatorBytes, ok := proxy["discriminator"]; ok {
		var discriminator Discriminator
		if err := yaml.Unmarshal(discriminatorBytes, &discriminator); err != nil {
			return err
		}
		v.discriminator = &discriminator
	}

	if readOnlyBytes, ok := proxy["readOnly"]; ok {
		t, err := strconv.ParseBool(string(readOnlyBytes))
		if err != nil {
			return err
		}
		v.readOnly = t
	}

	if writeOnlyBytes, ok := proxy["writeOnly"]; ok {
		t, err := strconv.ParseBool(string(writeOnlyBytes))
		if err != nil {
			return err
		}
		v.writeOnly = t
	}

	if xmlBytes, ok := proxy["xml"]; ok {
		var xml XML
		if err := yaml.Unmarshal(xmlBytes, &xml); err != nil {
			return err
		}
		v.xml = &xml
	}

	if externalDocsBytes, ok := proxy["externalDocs"]; ok {
		var externalDocs ExternalDocumentation
		if err := yaml.Unmarshal(externalDocsBytes, &externalDocs); err != nil {
			return err
		}
		v.externalDocs = &externalDocs
	}

	if exampleBytes, ok := proxy["example"]; ok {
		var example interface{}
		if err := yaml.Unmarshal(exampleBytes, &example); err != nil {
			return err
		}
		v.example = example
	}

	if deprecatedBytes, ok := proxy["deprecated"]; ok {
		t, err := strconv.ParseBool(string(deprecatedBytes))
		if err != nil {
			return err
		}
		v.deprecated = t
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}

	if referenceBytes, ok := proxy["$ref"]; ok {
		v.reference = string(referenceBytes)
	}
	return nil
}

func (v *Discriminator) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if propertyNameBytes, ok := proxy["propertyName"]; ok {
		v.propertyName = string(propertyNameBytes)
	}

	if mappingBytes, ok := proxy["mapping"]; ok {
		var mapping map[string]string
		if err := yaml.Unmarshal(mappingBytes, &mapping); err != nil {
			return err
		}
		v.mapping = mapping
	}
	return nil
}

func (v *XML) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if nameBytes, ok := proxy["name"]; ok {
		v.name = string(nameBytes)
	}

	if namespaceBytes, ok := proxy["namespace"]; ok {
		v.namespace = string(namespaceBytes)
	}

	if prefixBytes, ok := proxy["prefix"]; ok {
		v.prefix = string(prefixBytes)
	}

	if attributeBytes, ok := proxy["attribute"]; ok {
		t, err := strconv.ParseBool(string(attributeBytes))
		if err != nil {
			return err
		}
		v.attribute = t
	}

	if wrappedBytes, ok := proxy["wrapped"]; ok {
		t, err := strconv.ParseBool(string(wrappedBytes))
		if err != nil {
			return err
		}
		v.wrapped = t
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *SecurityScheme) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if type_Bytes, ok := proxy["type"]; ok {
		v.type_ = string(type_Bytes)
	}

	if v.type_ != "" {
		if isOneOf(v.type_, []string{"apiKey", "http", "oauth2", "openIdConnect"}) {
			return errors.New(`"type" field must be one of ["apiKey", "http", "oauth2", "openIdConnect"]`)
		}
	}

	if descriptionBytes, ok := proxy["description"]; ok {
		v.description = string(descriptionBytes)
	}

	if nameBytes, ok := proxy["name"]; ok {
		v.name = string(nameBytes)
	}

	if inBytes, ok := proxy["in"]; ok {
		v.in = string(inBytes)
	}

	if v.in != "" {
		if isOneOf(v.in, []string{"query", "header", "cookie"}) {
			return errors.New(`"in" field must be one of ["query", "header", "cookie"]`)
		}
	}

	if schemeBytes, ok := proxy["scheme"]; ok {
		v.scheme = string(schemeBytes)
	}

	if bearerFormatBytes, ok := proxy["bearerFormat"]; ok {
		v.bearerFormat = string(bearerFormatBytes)
	}

	if flowsBytes, ok := proxy["flows"]; ok {
		var flows OAuthFlows
		if err := yaml.Unmarshal(flowsBytes, &flows); err != nil {
			return err
		}
		v.flows = &flows
	}

	if openIDConnectURLBytes, ok := proxy["openIdConnectUrl"]; ok {
		v.openIDConnectURL = string(openIDConnectURLBytes)
	}

	if v.openIDConnectURL != "" {
		if _, err := url.ParseRequestURI(v.openIDConnectURL); err != nil {
			return err
		}
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}

	if referenceBytes, ok := proxy["$ref"]; ok {
		v.reference = string(referenceBytes)
	}
	return nil
}

func (v *OAuthFlows) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if implicitBytes, ok := proxy["implicit"]; ok {
		var implicit OAuthFlow
		if err := yaml.Unmarshal(implicitBytes, &implicit); err != nil {
			return err
		}
		v.implicit = &implicit
	}

	if passwordBytes, ok := proxy["password"]; ok {
		var password OAuthFlow
		if err := yaml.Unmarshal(passwordBytes, &password); err != nil {
			return err
		}
		v.password = &password
	}

	if clientCredentialsBytes, ok := proxy["clientCredentials"]; ok {
		var clientCredentials OAuthFlow
		if err := yaml.Unmarshal(clientCredentialsBytes, &clientCredentials); err != nil {
			return err
		}
		v.clientCredentials = &clientCredentials
	}

	if authorizationCodeBytes, ok := proxy["authorizationCode"]; ok {
		var authorizationCode OAuthFlow
		if err := yaml.Unmarshal(authorizationCodeBytes, &authorizationCode); err != nil {
			return err
		}
		v.authorizationCode = &authorizationCode
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *OAuthFlow) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if authorizationURLBytes, ok := proxy["authorizationUrl"]; ok {
		v.authorizationURL = string(authorizationURLBytes)
	}

	if v.authorizationURL != "" {
		if _, err := url.ParseRequestURI(v.authorizationURL); err != nil {
			return err
		}
	}

	if tokenURLBytes, ok := proxy["tokenUrl"]; ok {
		v.tokenURL = string(tokenURLBytes)
	}

	if v.tokenURL != "" {
		if _, err := url.ParseRequestURI(v.tokenURL); err != nil {
			return err
		}
	}

	if refreshURLBytes, ok := proxy["refreshUrl"]; ok {
		v.refreshURL = string(refreshURLBytes)
	}

	if v.refreshURL != "" {
		if _, err := url.ParseRequestURI(v.refreshURL); err != nil {
			return err
		}
	}

	if scopesBytes, ok := proxy["scopes"]; ok {
		var scopes map[string]string
		if err := yaml.Unmarshal(scopesBytes, &scopes); err != nil {
			return err
		}
		v.scopes = scopes
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	return nil
}

func (v *SecurityRequirement) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}
	securityRequirement := map[string][]string{}
	for key, val := range proxy {
		var securityRequirementv []string
		if err := yaml.Unmarshal(val, &securityRequirementv); err != nil {
			return err
		}
		securityRequirement[key] = securityRequirementv
	}
	if len(securityRequirement) != 0 {
		v.securityRequirement = securityRequirement
	}
	return nil
}
